quit
n
nn
n
sc
s
ss
s
n
c
disp child
disp target_value
disp self
quit
n
disp target_value
disp queue
disp self
disp current.value
n
disp current
disp queue
disp self
disp target_value
n
disp current
disp target_value
disp self
disp queue
quit
n
s
disp children
disp child
disp current
disp self
disp queue
disp target_value
quit
n
s
n
s
n
s
n
disp target_value
disp search_val
disp child
disp children
disp self
quit
n
search_val.value
n
s
n
s
n
s
n
disp search_val
disp child
disp target_value
disp self
quit
[self].value
self.value
n
c
n
disp visited
disp target_value
disp node.value
disp node
disp self
disp queue
quit
n
c
n
s
n
s
n
disp node.value
disp target_value
disp node
disp visited
disp self
disp queue
quit
exit
b.win_diagonal?(:X)
b.print
b.place_mark([2, 2],:X)
b.print
b.place_mark([0, 0],:X)
b.win_diagonal?(:X)
b.print
b = Board.new
load "board.rb"
b.win_diagnol?(:X)
b.print
b.empty_positions?
b.win?(:X)
b.win?
b.print
b.place_mark([1, 0], :X)
b.print
b.place_mark([1, 2], :X)
b = Board.new
load "board.rb"
b.print
b.place_mark([1, 2]: X)
b = Board.new
load "board.rb"
exit
cls
b
b.place_mark([1, 2], :O)
b
b.place_mark([1, 2], :X)
b = Board.new
load "board.rb"
b.place_mark([1, 2], :X)
b = Board.new
load "board.rb"
b
b.place_mark([1, 2], :X)
b
b.place_mark([-1, 1], :X)
b = Board.new
load "board.rb"
b.place_mark([1, 52], :X)
